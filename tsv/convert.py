"""convert.py - programs to convert stacks to output formats"""

import argparse
import multiprocessing
import numpy as np
import os
import tifffile
from .volume import VExtent, TSVVolume
import tqdm

v = None


def convert_to_2D_tif(xml_path, output_pattern,
                      mipmap_level=None,
                      volume=None,
                      dtype=None,
                      silent=False,
                      compression=4,
                      cores=multiprocessing.cpu_count()):
    """Convert a terastitched volume to TIF

    :param xml_path: Path to terastitcher xml output file
    :param output_pattern: File naming pattern. output_pattern.format(z=z) is
         called to get the path names for each TIF plane. The directory must
         already exist.
    :param mipmap_level: mipmap decimation level, e.g. "2" to output files
         at 1/4 resolution.
    :param volume: an optional VExtent giving the volume to output
    :param dtype: an optional numpy dtype, defaults to the dtype indicated
                  by the bit depth
    :param cores: # of processes to run simultaneously
    """
    global v
    v = TSVVolume.load(xml_path)
    if volume is None:
        volume = v.volume
    if dtype is None:
        dtype = v.dtype
    if mipmap_level is not None:
        decimation = 2 ** mipmap_level
    else:
        decimation = 1
    futures = []
    with multiprocessing.Pool(cores) as pool:
        for z in range(volume.z0, volume.z1, decimation):
            futures.append(pool.apply_async(
                convert_one_plane,
                (compression, decimation, dtype, mipmap_level, output_pattern,
                 volume, z)))
        for future in tqdm.tqdm(futures):
            future.get()


def convert_one_plane(compression, decimation, dtype, mipmap_level, output_pattern, volume, z):
    global v

    mini_volume = VExtent(
        volume.x0, volume.x1, volume.y0, volume.y1, z, z + 1)
    plane = v.imread(mini_volume, dtype)[0]
    if mipmap_level is not None:
        plane = plane[::decimation, ::decimation]
    path = output_pattern.format(z=z)
    tifffile.imsave(path, plane, compress=compression)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--xml-path",
        required=True,
        help="Path to the XML file generated by Terastitcher")
    parser.add_argument(
        "--output-pattern",
        required=True,
        help='Pattern for tif files, e.g. "output/img_{z:04d}.tif"')
    parser.add_argument(
        "--mipmap-level",
        default=0,
        type=int,
        help="Image decimation level, e.g. --mipmap-level=2 means 4x4x4 "
        "smaller image")
    parser.add_argument(
        "--volume",
        default="",
        help='Volume to be captured. Format is "<x0>,<x1>,<y0>,<y1>,<z0>,<z1>".'
        ' Default is whole volume.')
    parser.add_argument(
        "--compression",
        default=4,
        type=int,
        help="TIFF compression level (0-9, default=3)")
    parser.add_argument(
        "--silent",
        action="store_true")
    args = parser.parse_args()
    if args.mipmap_level == 0:
        mipmap_level = None
    else:
        mipmap_level = args.mipmap_level
    if args.volume != "":
        x0, x1, y0, y1, z0, z1 = map(int, args.volume.split(","))
        volume = VExtent(x0, x1, y0, y1, z0, z1)
    else:
        volume = None
    convert_to_2D_tif(args.xml_path,
                      args.output_pattern,
                      mipmap_level=mipmap_level,
                      volume=volume,
                      silent=args.silent,
                      compression=args.compression)


if __name__ == "__main__":
    main()